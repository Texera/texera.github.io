<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.3dba5d6040a4881d63e49604f8058c2bd1bd4e0b1f90277da3335388da407cb3cdb0ddde89c7815107e4f7fcfa6aded5fdf6b5c7cc32ec54bd85e740300c3148.css integrity="sha512-PbpdYECkiB1j5JYE+AWMK9G9TgsfkCd9ozNTiNpAfLPNsN3eiceBUQfk9/z6at7V/fa1x8wy7FS9hedAMAwxSA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation - Texera</title><meta name=description content="Background # What are operator properties # Texera workflows consist of operators. Every operator has properties as the parameters of its data-process function. For example, in Figure 1, the &amp;ldquo;Filter&amp;rdquo; operator has three properties, Attribute, Condition, and Value.
Some attribute properties accept input attribute names as values, usually describing the attributes that the operator applies. In this operator, Attribute is an attribute property, and price is the attribute to which the filter will apply."><link rel=canonical href=/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation"><meta property="og:description" content="Background # What are operator properties # Texera workflows consist of operators. Every operator has properties as the parameters of its data-process function. For example, in Figure 1, the &ldquo;Filter&rdquo; operator has three properties, Attribute, Condition, and Value.
Some attribute properties accept input attribute names as values, usually describing the attributes that the operator applies. In this operator, Attribute is an attribute property, and price is the attribute to which the filter will apply."><meta property="og:url" content="/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/"><meta property="og:site_name" content="Texera"><meta property="article:published_time" content="2023-06-18T20:58:20-07:00"><meta property="article:modified_time" content="2023-06-18T20:58:20-07:00"><meta property="og:image" content="doks.png"><meta property="og:image:alt" content="Texera"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation"><meta name=twitter:description content><meta name=twitter:image content="doks.png"><meta name=twitter:image:alt content="Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"/#/schema/organization/1","name":"Texera","url":"/","sameAs":["https://github.com/texera/texera"],"logo":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/logo-doks.png","width":512,"height":512,"caption":"Texera"},"image":{"@id":"/#/schema/image/1"}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"Texera","description":"Texera is a system to support collaborative, ML-centric data analytics as a cloud-based service using GUI-based workflows. It supports scalable computation with a parallel backend engine, and enables advanced AI\/ML techniques.","publisher":{"@id":"/#/schema/organization/1"}},{"@type":"WebPage","@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/","url":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/","name":"Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation","description":"","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/organization/1"},"datePublished":"2023-06-18T20:58:20CET","dateModified":"2023-06-18T20:58:20CET","breadcrumb":{"@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/"]}]},{"@type":"BreadcrumbList","@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"","url":"","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"/blog/","url":"/blog/","name":"Blog"}},{"@type":"ListItem","position":4,"item":{"@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"/#/schema/article/1","headline":"Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation","description":"","isPartOf":{"@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/"},"mainEntityOfPage":{"@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/"},"datePublished":"2023-06-18T20:58:20CET","dateModified":"2023-06-18T20:58:20CET","author":{"@id":"/#/schema/person/2"},"publisher":{"@id":"/#/schema/organization/1"},"image":{"@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"/#/schema/person/2","name":"Texera Team","sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/blog/enhancing-attribute-autocomplete-functionality-auto-correction-and-type-validation/#/schema/image/2","url":"doks.png","contentUrl":"doks.png","caption":"Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=site.webmanifest></head><body class="blog single"><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-fluid flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=Texera>Texera</a>
<button class="btn btn-menu d-block d-md-none order-5" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-md-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-md-none"></div><div class="offcanvas-header d-md-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>Texera</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body px-4"><h3 class="h6 text-uppercase mb-3 d-md-none">Main</h3><ul class="nav flex-column flex-md-row ms-md-n3"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/blog/>Blog</a></li></ul><hr class="text-black-50 my-4 d-md-none"><h3 class="h6 text-uppercase mb-3 d-md-none">Socials</h3><ul class="nav flex-column flex-md-row ms-md-auto me-md-n5 pe-md-2"><li class=nav-item><a class="nav-link ps-0 py-1" href=/https:/github.com/h-enk/doks><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-md-none">GitHub</small></a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/https:/twitter.com/getdoks><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg><small class="ms-2 d-md-none">Twitter</small></a></li></ul></div></div></nav></header><div class="wrap container-fluid" role=document><div class=content><div class="row justify-content-center"><div class="col-md-12 col-lg-10 col-xl-8"><article><div class=blog-header><h1>Enhancing Attribute Autocomplete Functionality - Auto Correction and Type Validation</h1><p><small>Posted June 18, 2023
by
<a class="stretched-link position-relative" href=/contributors/chengxi-li/>Chengxi Li</a>
from
<a class="stretched-link position-relative" href=/affiliations/computer-science-uc-irvine/>Computer Science, UC Irvine</a>
&nbsp;&dash;&nbsp;
<strong>12&nbsp;min read</strong></small><p></div><p class=lead>In this blog, we discuss the two new enhancements added to the attribute autocomplete feature in Texera, auto attribute correction and attribute type validation.</p><h2 id=background>Background <a href=#background class=anchor aria-hidden=true>#</a></h2><h3 id=what-are-operator-properties>What are operator properties <a href=#what-are-operator-properties class=anchor aria-hidden=true>#</a></h3><p>Texera workflows consist of operators. Every operator has properties as the parameters of its data-process function. For example, in Figure 1, the &ldquo;Filter&rdquo; operator has three properties, <code>Attribute</code>, <code>Condition</code>, and <code>Value</code>.</p><p>Some attribute properties accept input attribute names as values, usually describing the attributes that the operator applies. In this operator, <code>Attribute</code> is an attribute property, and <code>price</code> is the attribute to which the filter will apply. The property values in Figure 1 indicate that the operator filters the records with an <code>price</code> greater than 20.</p><figure align=center><img src=filter-operator-editor.png alt="Figure 1" style=max-width:18rem><figcaption><i>Figure 1: Filter Operator Properties</i></figcaption></figure><h3 id=what-are-operator-input-schemas>What are operator input schemas <a href=#what-are-operator-input-schemas class=anchor aria-hidden=true>#</a></h3><p>Various formats of data can be processed by Texera, and the format of data is represented by its schema, which is a set of attributes. In order to let every operator know what attributes of the data are available, each operator deduces its output schema using its input schema and propagates it to the next operator(s). The propagation is done in a topological order from source operators to sink operators. This process, called &ldquo;schema propagation,&rdquo; is an important part of the system, as it is the base of many useful features such as operator validation and attribute autocomplete.</p><h3 id=what-is-attribute-autocomplete>What is attribute autocomplete <a href=#what-is-attribute-autocomplete class=anchor aria-hidden=true>#</a></h3><p>Many operators have properties that accept an input attribute name as the value. For example, the <code>Attribute</code> property in the &ldquo;Sentiment Analysis&rdquo; operator takes the name of the attribute on which it will perform analysis. The autocomplete feature allows users to select an input attribute from a dropdown menu instead of manually typing in the name.</p><figure align=center><img src=autocomplete-dropdown-menu.png alt="Figure 2" style=max-width:18rem><figcaption><i>Figure 2: Dropdown Menu for Attribute Autocomplete</i></figcaption></figure><h2 id=auto-attribute-correction>Auto Attribute Correction <a href=#auto-attribute-correction class=anchor aria-hidden=true>#</a></h2><p>PR: <a href=https://github.com/Texera/texera/pull/1663>https://github.com/Texera/texera/pull/1663</a></p><h3 id=motivation>Motivation <a href=#motivation class=anchor aria-hidden=true>#</a></h3><p>In the old version of Texera, when an attribute name in the input schema of an operator changes, the field of this operator that selects the attribute will not update its value according to the change in the attribute name, and the operator will therefore become invalid. Intuitively, it is expected that the field will be updated accordingly. Moreover, when an attribute is deleted from the input schema, the field of the operator that contains the attribute will not be cleared and the operator will not be invalidated. It will cause a runtime error that the user cannot see in the backend, due to the invalid attribute selection, when the user tries to execute the workflow. To avoid this problem, it is expected to clear the fields containing the deleted attribute and invalidate the operator.</p><p>Therefore, we introduce an auto attribute correction feature that automatically corrects the attribute selection in operators whenever an attribute is renamed or deleted.</p><h3 id=demonstration>Demonstration <a href=#demonstration class=anchor aria-hidden=true>#</a></h3><p>The auto attribute correction feature updates the attribute selection in an operator under the following circumstances</p><ol><li>when the attribute selected in the operator is renamed, or</li><li>when the attribute selected in the operator is deleted.</li></ol><p>Note that when a new attribute is added or when the attribute is cast to another type, the auto attribute correction feature does no action.</p><h4 id=when-an-attribute-is-renamed>When an attribute is renamed <a href=#when-an-attribute-is-renamed class=anchor aria-hidden=true>#</a></h4><p>When a user renames an attribute through an operator, the attribute name will be updated in all the succeeding operators. Figure 3 shows how the attribute selection is automatically updated in the &ldquo;Sentiment Analysis&rdquo; operator when the attribute name is renamed in its preceding &ldquo;Column Rename&rdquo; (projection) operator. When the user renames the attribute <code>"content"</code> to <code>"tweet_text"</code> in the &ldquo;Column Rename&rdquo; (projection) operator, the <code>Attribute</code> field whose value was <code>"content"</code> in the succeeding “Sentiment Analysis” operator is automatically updated to <code>"tweet_text"</code>.</p><figure align=center><img src=auto-attribute-correction-process.gif alt="Figure 3"><figcaption><i>Figure 3: Auto Correction Process When an Attribute Is Renamed</i></figcaption></figure><h4 id=when-an-attribute-is-deleted>When an attribute is deleted <a href=#when-an-attribute-is-deleted class=anchor aria-hidden=true>#</a></h4><p>In case where an attribute selected in an operator is deleted, e.g., deselected in a projection operator, all succeeding operators containing the attribute will delete the attribute from themselves and become invalid.</p><h3 id=implementation>Implementation <a href=#implementation class=anchor aria-hidden=true>#</a></h3><p>To automatically correct the attribute selection in operators&rsquo; properties, we need to do the following steps when the input schema changes:</p><ol><li>Determine what input attribute changes (rename or delete);</li><li>Correct the attribute selection</li></ol><h4 id=determine-attribute-change>Determine attribute change <a href=#determine-attribute-change class=anchor aria-hidden=true>#</a></h4><p>It is easy for an operator to know when its input schema is changed. However, it can be challenging to determine what attribute is changed and what it changes to because all an operator knows about its input is the input schema, which is a list of attribute names and types.</p><p>In our auto attribute correction implementation, we choose to compare the input schema before the change and that after the change. That is, we keep a copy of the input schemas for all operators. When an input schema changes, we compare the new input schema with the last input schema in our copy and determine the change.</p><p>When comparing the old and new input schemas, we can find what attributes are unchanged. But there may be attributes in the old and new input schemas that do not match, which means that these attributes may be 1) newly created in the new schema, 2) renamed, or 3) deleted in the new schema.</p><p>Tables 1 and 2 are examples of the old and new input schemas. Let us try to determine how it changes. Here is a possible situation that happened to the input schema. Attribute <code>id</code> is unchanged since it exists in both schemas. <code>favorite_count</code> is deleted since it exists in the old schema but disappeared in the new schema. <code>content</code> is renamed to <code>text</code> since <code>content</code> is no longer there in the new schema but there&rsquo;s a new <code>text</code> with the same string type in the new schema. Lastly, <code>retweeted</code> is a new attribute since there is no attribute similar to it in the old schema.</p><p>However, this difference could be inaccurate. It is possible that <code>content</code> is not renamed but deleted, and <code>text</code> is a new attribute with the same type string. Moreover, it is also possible that <code>favorite_count</code> is not deleted but renamed to <code>retweeted</code> and converted from integer type to boolean type.</p><figcaption align=center><i>Table 1: Old Input Schema (Example 1)</i></figcaption><table><thead><tr><th>Attribute Name</th><th>Attribute Type</th></tr></thead><tbody><tr><td>id</td><td>integer</td></tr><tr><td>favorite_count</td><td>integer</td></tr><tr><td>content</td><td>string</td></tr></tbody></table><figcaption align=center><i>Table 2: New Input Schema (Example 1)</i></figcaption><table><thead><tr><th>Attribute Name</th><th>Attribute Type</th></tr></thead><tbody><tr><td>id</td><td>integer</td></tr><tr><td>text</td><td>string</td></tr><tr><td>retweeted</td><td>boolean</td></tr></tbody></table><p>Given that the determination is not unique, we need an algorithm to determine what are the most likely attribute changes that happened to the input schema. With the algorithm, we can know for the unmatched attribute, which attribute in the old schema corresponds to the attribute in the new schema, or whether an attribute is created or deleted. Inspired by how we compute the similarity between two strings using edit distance as the metric, we adapt our own edit distance algorithm to compute the similarity between two attributes (name and type).</p><p>In the Levenshtein edit distance algorithm used for strings <a href=https://en.wikipedia.org/wiki/Levenshtein_distance>https://en.wikipedia.org/wiki/Levenshtein_distance</a>, the distance is measured by the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into the other. For example, the distance between &ldquo;<strong>k</strong>itten&rdquo; and &ldquo;<strong>s</strong>itten&rdquo; is 1 because of a single substitution of &ldquo;s&rdquo; for &ldquo;k&rdquo;.</p><p>In our attribute edit distance algorithm, we compute the distance based on the name and the type. Unlike the Levenshtein distance where single-character insertions, deletions, and substitutions all have the same distance 1, we consider insertion and deletion to have a distance 1, and update to have various distances depending on the name and type change, reflected in Table 3.</p><p>The distance is based on the likelihood of the change. For the edit distance of an update, if either the attribute name or type is changed, it has a distance of 1. If both the attribute name and type are changed, it is considered unlikely, thus having a distance of 2.</p><figcaption align=center><i>Table 3: Attribute Edit Distance</i></figcaption><table><thead><tr><th>Attribute Change</th><th>Distance</th></tr></thead><tbody><tr><td>Insertion</td><td>1</td></tr><tr><td>Deletion</td><td>1</td></tr><tr><td>Update</td><td>1 or 2 (See Table 4)</td></tr></tbody></table><figcaption align=center><i>Table 4: Attribute Edit Distance for Update</i></figcaption><table><thead><tr><th>Attribute Name</th><th>Attribute Type</th><th>Distance</th></tr></thead><tbody><tr><td>Changed</td><td>Unchanged</td><td>1</td></tr><tr><td>Unchanged</td><td>Changed</td><td>1</td></tr><tr><td>Changed</td><td>Changed</td><td>2</td></tr></tbody></table><p>With this algorithm, for the example above, we can say that <code>content</code> is renamed to <code>text</code>, instead of that <code>content</code> is deleted and <code>text</code> is a new attribute, because the former case has a distance value of 1 (update of distance 1), while the later case has a distance value of 2 (one deletion + one insertion). Also, <code>favorite_count</code> is deleted instead of being renamed and typecasted to <code>retweeted</code>, because deletion only has a distance of 1, but the rename and typecasting is considered an update of a distance of 2.</p><h4 id=correct-attribute-selection>Correct attribute selection <a href=#correct-attribute-selection class=anchor aria-hidden=true>#</a></h4><p>In every operator involved in input schema changes, we update the attribute selection in the operators. The property update is conducted recursively because the object of operator properties can be nested with deep properties. All property values are recursively traversed to find the property with the value of the old attribute name and update with the new attribute name.</p><h3 id=limitations>Limitations <a href=#limitations class=anchor aria-hidden=true>#</a></h3><p>The implementation of the auto attribute correction cannot always find the correct attribute changes because of the attribute edit distance algorithm. We should notice due to the limited information that an operator has about its input schema, it can only &ldquo;guess&rdquo; what changes happened, but cannot confidently determine the changes. While we find out the most likely changes using our edit distance algorithm, the method shall not be considered 100% correct. Moreover, in some cases, two possible changes may have the same edit distance. In the example of Tables 4 and 5, it is possible that <code>user_id</code> is renamed to <code>uid</code> and <code>username</code> is renamed to <code>name</code>. It is also possible that <code>user_id</code> is renamed to <code>name</code> and <code>username</code> is renamed to <code>uid</code>. Both possibilities have a distance of 2. In this case, our edit distance algorithm may take either result.</p><figcaption align=center><i>Table 5: Old Input Schema (Example 2)</i></figcaption><table><thead><tr><th>Attribute Name</th><th>Attribute Type</th></tr></thead><tbody><tr><td>user_id</td><td>integer</td></tr><tr><td>username</td><td>integer</td></tr></tbody></table><figcaption align=center><i>Table 6: New Input Schema (Example 2)</i></figcaption><table><thead><tr><th>Attribute Name</th><th>Attribute Type</th></tr></thead><tbody><tr><td>uid</td><td>integer</td></tr><tr><td>name</td><td>integer</td></tr></tbody></table><h2 id=attribute-type-validation>Attribute Type Validation <a href=#attribute-type-validation class=anchor aria-hidden=true>#</a></h2><p><em>Issue: <a href=https://github.com/Texera/texera/issues/1889>https://github.com/Texera/texera/issues/1889</a></em></p><p><em>PR: <a href=https://github.com/Texera/texera/pull/1924>https://github.com/Texera/texera/pull/1924</a>, <a href=https://github.com/Texera/texera/pull/2005>https://github.com/Texera/texera/pull/2005</a></em></p><h3 id=motivation-1>Motivation <a href=#motivation-1 class=anchor aria-hidden=true>#</a></h3><p>Many operators have type constraints on the attribute they process. For example, the &ldquo;Sentiment Analysis&rdquo; operator is designed for text analysis, so it should only accept string-typed attributes as input. However, the attribute autocomplete feature allows users to select attributes with any type from the dropdown list. As a result, users may select a wrong attribute that cannot be handled by the operator, or produce meaningless results. Therefore, we introduce an attribute type validation feature to warn users when they select an attribute with a type not suitable in the context.</p><h3 id=demonstration-1>Demonstration <a href=#demonstration-1 class=anchor aria-hidden=true>#</a></h3><p>Operators have different constraints on the attribute type depending on their functionalities. We will take &ldquo;Sentiment Analysis&rdquo;, &ldquo;Hash Join&rdquo;, and &ldquo;Aggregate&rdquo; operators as an example.</p><h4 id=sentiment-analysis-operator>Sentiment Analysis Operator <a href=#sentiment-analysis-operator class=anchor aria-hidden=true>#</a></h4><p>The &ldquo;Sentiment Analysis&rdquo; operator takes one attribute of string type. When users select an attribute with an integer type, we prompt a warning message.</p><figure align=center><img src=sentiment-analysis-type-validation.png alt="Figure 4" style=max-width:18rem><figcaption><i>Figure 4: Sentiment Analysis Type Validation Example</i></figcaption></figure><h4 id=hash-join-operator>Hash Join Operator <a href=#hash-join-operator class=anchor aria-hidden=true>#</a></h4><p>The &ldquo;Hash Join&rdquo; operator requires the two key attributes to have the same type.</p><figure align=center><img src=hash-join-type-validation.png alt="Figure 5" style=max-width:18rem><figcaption><i>Figure 5: Hash Join Type Validation Example</i></figcaption></figure><h4 id=aggregate-operator>Aggregate Operator <a href=#aggregate-operator class=anchor aria-hidden=true>#</a></h4><p>The &ldquo;Aggregate&rdquo; operator supports multiple aggregation functions, such as <code>sum</code>, <code>count</code>, <code>concat</code>, etc. Each aggregation function has different requirements regarding its input attribute. For example, the <code>sum</code> function must be computed on a numeric type attribute (integer, long, double, or timestamp), and the <code>concat</code> function must be computed on a string type attribute, while the <code>count</code> function has no type requirement.</p><figure align=center><img src=aggregate-type-validation.png alt="Figure 6" style=max-width:18rem><figcaption><i>Figure 6: Aggregate Type Validation Example</i></figcaption></figure><h3 id=implementation-1>Implementation <a href=#implementation-1 class=anchor aria-hidden=true>#</a></h3><p>Given that each operator has different type constraints, we write attribute type rules for each operator that has type constraints and provide a warning when the attribute selection violates the rules. We will focus on how the type rules are written and checked. The attribute type rules are considered operator metadata and thus are a part of the operator schema supplied from the backend. As the operator schema is in the JSON Schema format, we designed our attribute type rules JSON to match the JSON Schema as much as possible. The attribute type rules are injected into operator schemas as an attribute called <code>attributeTypeRules</code>.</p><p>The attribute type rules may contain three constraints: <code>enum</code> that defines the possible values of the type, <code>const</code> (<code>const.$data</code>) that is used to check the equality of two attribute types, and <code>allOf</code> (for <code>if</code>-<code>then</code> sets) for more complicated cases. The rules may have multiple constraints but must satisfy all of them.</p><p>In general, our schema has the following format.</p><pre tabindex=0><code>{
  &#34;attributeTypeRules&#34;: {
    &#34;&lt;attribute name&gt;&#34;: {
      &lt;constraints&gt;
    },
    ...
  }
}
</code></pre><p>Here are the attribute type schemas for the three operators. Those schemas cover most common situations.</p><h3 id=check-if-the-attribute-type-is-in-a-set>Check if the attribute type is in a set <a href=#check-if-the-attribute-type-is-in-a-set class=anchor aria-hidden=true>#</a></h3><p>In the &ldquo;Sentiment Analysis&rdquo; operator, the attribute type of <code>attribute</code> must be a string.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;attributeTypeRules&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;attribute&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;enum&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;string&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=check-the-equality-of-two-attribute-types>Check the equality of two attribute types <a href=#check-the-equality-of-two-attribute-types class=anchor aria-hidden=true>#</a></h3><p>In the &ldquo;Hash Join&rdquo; operator, the attribute type of <code>buildAttributeName</code> (Left Input Attribute) must be equal to that of <code>probeAttributeName</code> (Right Input Attribute).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;attributeTypeRules&#34;</span><span class=p>:{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;buildAttributeName&#34;</span><span class=p>:{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;const&#34;</span><span class=p>:{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;$data&#34;</span><span class=p>:</span> <span class=s2>&#34;probeAttributeName&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><em>Note: the <code>$data</code> keyword is used to implement value comparison. Currently, it is the only way to check equality between values in JSON Schema. However, the <code>$data</code> keyword proposal is included not in the formal JSON Schema standard. See <a href=https://github.com/json-schema-org/json-schema-spec/issues/51>https://github.com/json-schema-org/json-schema-spec/issues/51</a>, and <a href=https://ajv.js.org/guide/combining-schemas.html#data-reference>https://ajv.js.org/guide/combining-schemas.html#data-reference</a>.</em></p><h3 id=attribute-type-dependent-on-other-propertys-value>Attribute type dependent on other property&rsquo;s value <a href=#attribute-type-dependent-on-other-propertys-value class=anchor aria-hidden=true>#</a></h3><p>In the &ldquo;Aggregate&rdquo; operator, if <code>aggFunction</code>&rsquo;s value is &ldquo;sum&rdquo;, &ldquo;average&rdquo;, &ldquo;min&rdquo;, or &ldquo;max&rdquo;, then the attribute type of &ldquo;attribute&rdquo; can only be numeric (integer, long, double, or timestamp). Similarly, if <code>aggFunction</code>&rsquo;s value is &ldquo;concat&rdquo;, then the attribute type of &ldquo;attribute must be &ldquo;string&rdquo;. If <code>aggFunction</code> has other values, like &ldquo;count&rdquo;, then it has no constraint.</p><p>All <code>if-then</code> in the <code>allOf</code> array must be satisfied.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;attributeTypeRules&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;attribute&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;allOf&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;if&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;aggFunction&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nt>&#34;valEnum&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;sum&#34;</span><span class=p>,</span> <span class=s2>&#34;average&#34;</span><span class=p>,</span> <span class=s2>&#34;min&#34;</span><span class=p>,</span> <span class=s2>&#34;max&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;then&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;enum&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;integer&#34;</span><span class=p>,</span> <span class=s2>&#34;long&#34;</span><span class=p>,</span> <span class=s2>&#34;double&#34;</span><span class=p>,</span> <span class=s2>&#34;timestamp&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;if&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;aggFunction&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nt>&#34;valEnum&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;concat&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;then&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;enum&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;string&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><em>Note: the <code>valEnum</code> in the <code>if</code> clause is comparing the actual literal value of the property, not the attribute type, as opposed to elsewhere in the attribute type schema, so we used a custom keyword <code>valEnum</code> instead of <code>enum</code> here.</em></p><h3 id=operators-with-type-rules>Operators with Type Rules <a href=#operators-with-type-rules class=anchor aria-hidden=true>#</a></h3><p>The following operators will have the type validation feature.</p><ul><li>Regular Expression</li><li>Dictionary Matcher</li><li>Keyword Search</li><li>Sentiment Analysis</li><li>Interval Join</li><li>Hash Join</li><li>Linear Regression</li><li>Sort Partitions</li><li>Aggregate</li><li>Unnest String</li><li>Type Casting</li><li>Word Cloud</li><li>ScatterPlot</li></ul><p>There may be more operators to be added in the future that will support type validation.</p><h2 id=acknowledgements>Acknowledgements <a href=#acknowledgements class=anchor aria-hidden=true>#</a></h2><p>Special thanks to Dr. Zuozhi Wang, Yicong Huang, Prof. Chen Li, and the Texera team for their help in the task and the blog.</p></article></div></div></div></div><footer class="footer text-muted"><div class=container-fluid><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=/js/bootstrap.min.0a0106334435d4110713bfaff4acaf02533b0c56d44412a74e9518db07672ddb7e099a9c7517bc9cb529e2ddd4ae2e438b40b720288900d5e74fb6d8928d9097.js integrity="sha512-CgEGM0Q11BEHE7+v9KyvAlM7DFbURBKnTpUY2wdnLdt+CZqcdRe8nLUp4t3Uri5Di0C3ICiJANXnT7bYko2Qlw==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.576fdb91cfd303e8fc247b90cc678e7d3304777de963077ad78eb70811a476919edaebf1d2843057250ec536b7ed1bd40f4e48f06e7cfc9c569dcf7581afd08b.js integrity="sha512-V2/bkc/TA+j8JHuQzGeOfTMEd33pYwd61463CBGkdpGe2uvx0oQwVyUOxTa37RvUD05I8G58/JxWnc91ga/Qiw==" crossorigin=anonymous defer></script>
<script src=/main.min.0382ba481d9dbcd1dd4c82111208ebf5d7eda2fce9378b0b14257d7f117c79f8ae01591f6ad0a99917b4e1624d8ace90de964e2431ab237000161ebd3c3dad63.js integrity="sha512-A4K6SB2dvNHdTIIREgjr9dftovzpN4sLFCV9fxF8efiuAVkfatCpmRe04WJNis6Q3pZOJDGrI3AAFh69PD2tYw==" crossorigin=anonymous defer></script></body></html>